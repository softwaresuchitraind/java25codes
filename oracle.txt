
CREATE USER MYDB4PM IDENTIFIED BY MYDB4PM;
ALTER USER MYDB4PM IDENTIFIED BY MYDB4PM;

DDL
=====
CREATE
-------
#to create a new table/ a new db object(table,view,synonyms,sequence......etc)

Syntax to create a new table in oracle
------------------------------------------
create table <table name>(<column name1><datatype>[size],<column name2><datatype>[size],...........)

#without datatype we can not create a table

datatype in oracle
=====================
-Numeric datatype
-String/ Character datatype
-Long datatype


number
====
int 
---
    #Storing integer value only
    #when we use "int" datatype on table number internally  datatype with max size is 38 digits

number 
----------
# Storing both interger and float values
#number(p)
#number(p,s)-stores float value

String/Character datatype
================================
1. Non-Unicode datatypes
    - these datatypes are storing localized data(eg English lang only)
        >char(size)
        >varchar2(size)
2. Unicode datatypes
    -these datatypes are storing globalized data(i.e all national languages)
        >Nchar(size)
        >Nvarchar2(size)

    - "N" ---- national languages

char(size)
==========
    - It is fixed datatypes(static)
    - storing non-unicode char's in the form of 1 char = 1 bytes
    - max.size is 2000 bytes(2000 chars = 2000 bytes)

Nvarchar2(size)
========================
unicode also save

Long:
=========
-it is a variable length datatype(dynamic)
-storing non-unicode & unicode chars in the form 1 char = 1 bytes
max-size is 2 gb.


Eaddress Long
==============
memory will not weast


Date datatypes
=============================

    -storing date and time information of a particular day.
    -range of datatype : from '01-jan-4712BC' to '31-dec-9999AD'
i> date 
    '12:00:00 am' - by default
    -oracle default date format is 'dd-mon-yyyy/yy hh:mi:ss'
    ex:
    '20-sep-2021 / 21 17:00:00'
-date datatype is occupied 7 bytes memory(fixed memory)

ii> timestamp
    -storing date and time information of a particular day along with milliseconds
     'dd-mon-yyyy/yy hh:mi:ss.ms'
     1     1  2       1  1  1  4
     -timestamp datatype is occupied 11 bytes memory(fixed memory)

Raw & Long Raw
===================
    -storing image files/ audio file /video -------convert into ------------>binary format
    -these datatypes are also called as "binary datatype"

LOB datatypes
=============
    -large object datatypes

    >Blob : binary large object ------> store image/audio/video file in the form of 01001010010101 
    >Clob : Character large object--------> storing non-unicode char's
    >NClob : national Character large object ------>storing unicode chars

==============================================================================================

1.non-unicode char'
=========================
    >char(size) ---------2000 bytes
    >varchar2(size)-------4000 bytes
    >Long ----------------2 gb
    >Clob ----------------128 table

    1.unicode char'
=========================
    >Nchar(size) ---------2000 bytes
    >Nvarchar2(size)-------4000 bytes
    >Long ----------------2 gb
    >NClob ----------------128 table

3. Binary data
==============
    >Raw -----------2000 bytes
    >Long Raw ---------2 gb
    >Blob--------------128 tb 


DDL
=========
CREATE
----------

GRANT DBA TO MYDB4PM;
SELECT * FROM TAB;
HOST CLS
SET LINESIZE 200
SET PAGESIZE 50
SQL> COLUMN TNAME FORMAT A20
SQL> COLUMN TYPE FORMAT A15
SQL> COLUMN CLUSTERID FORMAT A10
desc <table_name>
 COLUMN TNAME FORMAT A25
 SET LINESIZE 150

 ALTER
 ===========
    - To modify / change the structure of a table
            >to change datatype and size of datatype of a column
            >to add a new column to an existing column
            >to change the name of a column
            >to drop a column from a table
    - sub commands of alter command is :

i>Alter - modify
=====================
    to change datatype and size of datatype of a column

Syntax
========
Alter table<talbel name> modify<column name><new datatype>[new size]
ALTER TABLE STUDENT MODIFY SNAME VARCHAR2(20);

ii> Alter - add
=====================
    to add a new column to an existing column

Syntax
=========
Alter table<table_name> add<column name><datatype>[size]
ALTER TABLE STUDENT ADD SADDRESS VARCHAR2(10);

iii> Alter - rename
=====================
    to change the name of a column

Syntax
==========
Alter table<table_name> rename column<old column name> to <new column name>
ALTER TABLE STUDENT RENAME COLUMN SNAME TO STUDENT_NAME;
ALTER TABLE STUDENT RENAME COLUMN SNAME TO STUDENTNAMES;


IV> Alter - drop
=====================
    to drop a column from a table

Syntax
======
alter table<table_name> drop column <column_name\>
ALTER TABLE STUDENT DROP COLUMN SADDRESS;
ALTER TABLE STUDENT DROP COLUMN SFEE;

RENAME
==========
    - to change a table name in DB

Syntax
============
Rename <old table name> to <new table name>

ex
======
RENAME STUDENT SDETAILS;
SELECT * FROM TAB;
RNAME SDETAILS TO STUDENT;

TRUNCATE
=========
    -to delete all rows from a table at a time
    -deleting rows but not columns
    -cannot delete a specific row from a table
    -not supporting "where" clause condition.
    -deleting rows are permanent
INSERT INTO STUDENT VALUES(1023,'JONES','MUMBAI');
TRUNCATE TABLE STUDENT;

DROP
=========
    - to drop / delete a table(rows and columns ) from database memory.

drop table table_name;

SQL> DROP TABLE STUDENT;

Note :
==========
    before oracle 10 g enterprise edittion once we drop a table then it is permanently dropped and we can not restore a table.
from oracle 10g enterprise edition once we drop a table then it is temporarily droped and we can restore a table.

New features in Oracle 10g enterprise edition
===============================================
    > Recyclebin
    >flashback
    >purge

Recyclebin
=================
    - It is a pre-defined/system defined table.
    - is storing the information about the dropped tables
    - it is similar to windows recyclebin in computer.

TO VIEW DROPPED TABLE information
=========================================
 DESC RECYCLEBIN;
SELECT OBJECT_NAME,ORIGINAL_NAME FROM RECYCLEBIN;


Flashback
================
    - it is a command is used to restore a table from recyclebin to database.

Syntax
===========
flashback table <table_name> to before drop;

FLASHBACK TABLE STUDENT TO BEFORE DROP;

purge
========
    IT IS USED TO DROP a table from recyclebin permanently;
        (or)
    -it is used to drop a table from database permanently

i) to drop a specific table from recyclebin
============================================
Syntax
=======
purge table><table_name>;

purge table STUDENT;
PURGE TABLE TEST2;

ii> to drop all tables from recyclebin
========================================
Syntax
====
purge recyclebin;
PURGE RECYCLEBIN;

iii> to drop a table from database permanently.
Syntax
=========
drop table <table_name> purge;

DROP TABLE STUDENT PURGE;
DML 
=======

INSERT
========
        - to insert a new row data into a table.

Syntax1
=======
insert into <table_name> values(value1,value2,........);

Syntax2
===========
insert into <table_name> (<list of columns>)values(<value1>,<value2>,....);

Note : we can insert values for our required column only and remaining columns are taking null by default;

Substitutional operators
==============================
i)& - to insert values to column dynamically (we can change value for column) 
ii)&& - to insert fixed values to column( we can not change value for column). if we want to change value for
        a column then we should "exit" from oracle db.

Syntax1
============
insert into <table_name> values (&<column name1>,&<column name2>,......);

ex :
INSERT INTO EMPLOYEE VALUES(&EID,'&ENMAE',&SALARY);


/ - re-executed lastly executed query.

CL SCR

INSERT INTO EMPLOYEE VALUES(&EID,'&ENMAE',&&SALARY);

update
=========
    -to update all rows in a table at a time.
        (or)
    -to update a specific row data in a table by using "where" condition.

Syntax
==========
update<table_name> set <column name>=value1,<column name2>=<value2> where [<condition>];

v


SQL> SET PAGESIZE 100
SQL> SET LINES 100


SQL> SET PAGESIZE 100
SQL> SET LINES 100
SQL> UPDATE EMPLOYEE SET ENAME='SAI',SALARY=66000 WHERE EID=1031;

UPDATE EMPLOYEE SET SALARY=18000 WHERE ENAME='CLACK';

DELETE 
==============
    - to delete all rows data from a table
    (or)
    - to delete a specific row data from a table by using "where" condition.

Syntax
==========
delete from <table_name>[where<condition>]

DELETE FROM EMPLOYEE WHERE ENAME='CLACK';

DELETE VS TRUNCATE
=====================
delete
=========
- can delete a specific row data from a table by using "where"
-supporting "where" condition
-temporary data deletion
-can restore data by using rollback command.
- deleting rows from a table one by one row so that execution speed is slow.



TRUNCATE
=====
-not possible
-not supporting "where" condition
-permanent data deletion
-can not restore data by using rollback command.
-deleting rows from a table as a set of rows
so that exection speed is fast.


New commands
====================
    -insert all
    -Merge

DQL/DRl
==========
 - to retrieving all rows data from a table at a time
 (or)
 -to retrive a specific row data from a table by using "where" condition.

 Syntax
 ============
 select * /<list of columns> from 

 Note
 ===========
  - if we want to display a big data table in proper systematically in sqlplus editor then we should set some properties
for sqlplus environment.

1>PAGESIZE N;
==============
    -by default a page can display 14 rows
    1 page = 14 rows

- "n" no.of rows in a page.

    table -----------100 rows------------>8 pages 
eg
=======
set PAGESIZE 100;
set pagesize 200;
set pagesize 500;

2> Linesize N;

2)Line N
===========
By default system is allocating 80 bytes of memory for each line.

1 row data = 100 chars
10 rows -------------10 lines 

-----------------------------------80 chars--------------------------------------(80 bytes)
---------------------------------------nextline
----------------------------------
--------------------------
----------------------------------------------------------------------
-------------------------------------------------------20 chars line 

set lines 100;
SQL> set pagesize 50001
SP2-0267: pagesize option 50001 out of range (0 through 50000)
SQL> set linesize 32768
SP2-0267: linesize option 32768 out of range (1 through 32767)

CL SCR;
==========12=================================================
How to create a new table from the old table
===================================================
create table<new table_name> as select * from <old table_name>;

CREATE TABLE NEWDEPT AS SELECT * FROM DEPT;

Note- in this level, we are created a new table with copy of all rows and columns from the old table.

syntax2: to copy specific column data from old table to new table.
================================================================

create table <new table_name> as select <col1>,<clol2>,....from <old_table>

SQL> CREATE TABLE SPCOLUMN AS SELECT EMPNO,ENAME,SAL FROM EMP;

syntax3: to copy specific rows data from old table
=======================================================
create table <new table_name> as select * from <old table_name> where <condition>

SQL> CREATE TABLE SPROWS AS SELECT * FROM EMP WHERE DEPTNO=20;

syntax4
========
create a new table without copy rows data from a table
=====================================================
create table <new table_name> as select * from <old table_name> where <false condition>;
How to copy data from one table to another table
======================================================
syntax
========
insert into<destination table name> select * from <source table name>

Note: 
1. both tables (source & destination) structures are same.
2. order of columns must be same
3. datatype of column must match

INSERT INTO DUMMYDEPT SELECT * FROM DEPT;
Insert all :
================
 insert : to insert new data into a single table.
 insert all : to insert an existing table data(old data) into multiple tables at a time.

syntax
=========
insert all into <table name1> values (<column name1>,<column name2>,....));
insert all into <table name1> values (<column name1>,<column name2>,....));
------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
insert<table name n> values(<column name1>,<column name2>,....));

EMPTY NEW TABLE
========================
MERGE 
=====
    - is used to transfer data from source table to destination table.
            -if data is matching in both tables then those matching data is override on destination table by
             using "update" command.

            -if data is not matching then unmatching data is transfer from source table to destination table.

              Merge = update + insert

syntax
=========
Merge into   <destination table name><destination table alias name> using <source table name>
<source table alias name> on <joining condition>
when matched then
update set <destination table alias name>.<column name>=<source table alias name>.<column name>
when not matched then
insert (<destination table columns>)values()(<source table columns>)


==============13=============
Alias name:
===============
    It is  temporary/alternate name for column and also table.

    i>column level
    ========================
        we are creating alias name for column names.
    ii>table level
    ===============
        we are creating alias name for table name.

syntax
======
select<column1 name1><column alias name1>,<column1 name1><column alias name1>,... from <tn><table alias name>;


SQL> SELECT DEPTNO X,DNAME Y,LOC Z FROM DEPT D;

         X Y              Z
---------- -------------- -------------
        10 ACCOUNTING     NEW YORK
        20 RESEARCH       DALLAS
        30 SALES          CHICAGO
        40 OPERATIONS     BOSTON

SQL> MERGE INTO DEPT D USING SDEPT S ON(D.DEPTNO=S.DEPTNO)
  2  WHEN MATCHED THEN
  3  UPDATE SET D.DNAME=S.DNAME,D.LOC=S.LOC
  4  WHEN NOT MATCHED THEN
  5  INSERT(D.DEPTNO,D.DNAME,D.LOC)VALUES(S.DEPTNO,S.DNAME,S.LOC);



TRANSACTION CONTROL languages
=================================



Concatenation Operator(||)
=============================
- is used to join/ add two string expressions by using select statement.

syntax
==========
<string1>||<string2>||<string3>||<string4>

ex:
SELECT 'MR.'||ENAME||'IS WORKING AS A'||JOB FROM EMP;

DISTINCT KEYWORD
=======================
 - is used to eliminate duplicate values and display unique values.

syntax
=======
SQL> SELECT DISTINCT JOB FROM EMP;

JOB
---------
ANALYST
CLERK
SALESMAN
MANAGER
PRESIDENT


======14===================
Alias
======
===============================15===========================

NOT
========
-return all values except the given conditional value in the query.

syntax
==========
    where not<condition1> and mot <condition2>

ex
=====
wa to display employee who are not working in deptno 10 and 30

SQL> SELECT * FROM EMP WHERE NOT DEPTNO=10 AND NOT DEPTNO=20;
Set operators
============
- are used to combine the result of two select statements as a single set of values.
-union,union all,intersect,minus

synrax
=========
<select query1><set operator><select query2>

Ex
======

A={10,20,30}
B={30,40,50}

union
========
AUB - > {10,20,30,40,50}

-combined all set values without duplicate values

Union all
===========
-combined all set values with duplicate values
AUB - > {10,20,30,30,40,50}

intersect
===========
    -return common values.

A i B = {30}

minus
===========
    - returns all values from left set which are not found in right set.

A-B = {10,20}
B-A = {40,50}

EX- ALL EMPLOYEES DETAILS
============================

SQL> SELECT * FROM EMP_CHENNAI;

       EID ENAME             SAL
---------- ---------- ----------
      1021 SAI             85000
      1024 WARD            28000
      1025 MILLER          15000

SQL> SELECT * FROM EMP_HYD;

       EID ENAME             SAL
---------- ---------- ----------
      1021 SAI             85000
      1022 JOHN            45000
      1023 ADAMS           37000

SQL> SELECT * FROM EMP_HYD UNION SELECT * FROM EMP_CHENNAI;

       EID ENAME             SAL
---------- ---------- ----------
      1021 SAI             85000
      1022 JOHN            45000
      1023 ADAMS           37000
      1024 WARD            28000
      1025 MILLER          15000

SQL> SELECT * FROM EMP_HYD UNION ALL SELECT * FROM EMP_CHENNAI;

       EID ENAME             SAL
---------- ---------- ----------
      1021 SAI             85000
      1022 JOHN            45000
      1023 ADAMS           37000
      1021 SAI             85000
      1024 WARD            28000
      1025 MILLER          15000

6 rows selected.
EMPLOYEE WORKING IN bothLOC


SQL> SELECT * FROM EMP_HYD INTERSECT SELECT * FROM EMP_CHENNAI;


SQL> SELECT * FROM EMP_HYD INTERSECT SELECT * FROM EMP_CHENNAI;

       EID ENAME             SAL
---------- ---------- ----------
      1021 SAI             85000

EMPLOYEE WHO ARE WORKING IN HYD BUT NOT IN CHENAI;
=======================================================
SQL> SELECT * FROM EMP_HYD MINUS SELECT * FROM EMP_CHENNAI;


SQL> SELECT * FROM EMP_HYD MINUS SELECT * FROM EMP_CHENNAI;

       EID ENAME             SAL
---------- ---------- ----------
      1022 JOHN            45000
      1023 ADAMS           37000


SQL> SELECT * FROM EMP_CHENNAI MINUS SELECT * FROM EMP_HYD;

       EID ENAME             SAL
---------- ---------- ----------
      1024 WARD            28000
      1025 MILLER          15000

BASIC RULES
===========
1. both select queries should have a same no.of columns in the list.
2.those columns datatypes must be in both select queries.

SQL> SELECT * FROM EMP_HYD UNION SELECT EID,ENAME FROM EMP_CHENNAI;
SELECT * FROM EMP_HYD UNION SELECT EID,ENAME FROM EMP_CHENNAI
*
ERROR at line 1:
ORA-01789: query block has incorrect number of result columns


SQL> SELECT EID,ENAME FROM EMP_HYD UNION SELECT EID,ENAME FROM EMP_CHENNAI;

       EID ENAME
---------- ----------
      1021 SAI
      1022 JOHN
      1023 ADAMS
      1024 WARD
      1025 MILLER



SQL> SELECT EID,ENAME FROM EMP_HYD UNION SELECT ENAME,EID FROM EMP_CHENNAI;
SELECT EID,ENAME FROM EMP_HYD UNION SELECT ENAME,EID FROM EMP_CHENNAI
       *
ERROR at line 1:
ORA-01790: expression must have same datatype as corresponding expression

==========================================================16===============================
-Special operators
==================
(+ve) operators
===============

IN
-----
-comparing group of values in a single condition in the query.

ex
=
waq to display employee who are working as a manager \


SQL> SELECT * FROM EMP WHERE JOB IN('ANALYST','PRESIDENT','MANAGER');

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7839 KING       PRESIDENT            17-NOV-81       5000                    10
      7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30
      7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
      7566 JONES      MANAGER         7839 02-APR-81       2975                    20
      7788 SCOTT      ANALYST         7566 19-APR-87       3000                    20
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20

6 rows selected.


NOT IN
=========
SQL> SELECT * FROM EMP WHERE JOB NOT IN('ANALYST','PRESIDENT','MANAGER');

between
==========
- RANGE VALUES

EX- WHOSE SALRAY BETWEEN 1500-3000.

SQL> SELECT * FROM EMP WHERE SAL BETWEEN 1500 AND 3000;

EX:
Waq to display employee who are joined in the year 1981.

SQL> SELECT * FROM EMP WHERE HIREDATE BETWEEN '01-JAN-81' AND '31-DEC-81';
SQL> SELECT * FROM EMP WHERE HIREDATE BETWEEN '01-JAN-81' AND '31-DEC-81';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7839 KING       PRESIDENT            17-NOV-81       5000                    10
      7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30
      7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
      7566 JONES      MANAGER         7839 02-APR-81       2975                    20
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30
      7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30
      7900 JAMES      CLERK           7698 03-DEC-81        950                    30


NOT BETWEEN
================
SQL> SELECT * FROM EMP WHERE SAL NOT BETWEEN 1500 AND 3000;

SQL> SELECT * FROM EMP WHERE HIREDATE NOT BETWEEN '01-JAN-81' AND '31-DEC-81';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7788 SCOTT      ANALYST         7566 19-APR-87       3000                    20
      7369 SMITH      CLERK           7902 17-DEC-80        800                    20
      7876 ADAMS      CLERK           7788 23-MAY-87       1100                    20
      7934 MILLER     CLERK           7782 23-JAN-82       1300                    10

IS NULL 
==========
 -comparing nulls in a table.

SQL> SELECT * FROM EMP WHERE COMM IS NULL;
SQL> SELECT * FROM EMP WHERE COMM IS NOT NULL;

SQL> SELECT * FROM EMP WHERE COMM=300;

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
SQL> SELECT * FROM EMP WHERE COMM=0;

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30

SQL> SELECT * FROM EMP WHERE COMM=NULL;

no rows selected

SQL> SELECT * FROM EMP WHERE COMM IS NULL;

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7839 KING       PRESIDENT            17-NOV-81       5000                    10
      7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30
      7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
      7566 JONES      MANAGER         7839 02-APR-81       2975                    20
      7788 SCOTT      ANALYST         7566 19-APR-87       3000                    20
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
      7369 SMITH      CLERK           7902 17-DEC-80        800                    20
      7876 ADAMS      CLERK           7788 23-MAY-87       1100                    20
      7900 JAMES      CLERK           7698 03-DEC-81        950                    30
      7934 MILLER     CLERK           7782 23-JAN-82       1300                    10

      SQL> SELECT * FROM EMP WHERE COMM IS  NOT NULL;

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30
      7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30


Working with null
==================
- Generally in db NULL is called as Unknown/Undefined value.

-NULL !=0
null != space

SQL> SELECT ENAME,JOB,SAL,COMM,SAL+COMM FROM EMP WHERE ENAME='ALLEN';

ENAME      JOB              SAL       COMM   SAL+COMM
---------- --------- ---------- ---------- ----------
ALLEN      SALESMAN        1600        300       19

=======================17==============================================================

NOTE 
======
- Generally if any arithmatic operator is performing some operation with NULL then it again return NULL.

Ex
=====
if x = 1000;
i>x+null ==============>1000+null===============>null
ii>x-null=============>1000-null===============>null    
iii>x*null=============>1000*null===============>null
iv>x/null=============>1000/null===============>null

NVL(EXP1,EXP2)
====================
-NVL stands for null value
-predefined function which is used replace a user defined value in place of NULL

10---------------------->null

> if EXP1 is null ---------->then -----------------> EXP2 value(Userdefined value)

Ex :   NVL(null,0)------------>
       NVL(null,100)------------>100
       NVL(null,50)------------->50

>if EXP1 is not null---------->then ------------returns--------->EXP1 value only

ex:

NVL(0,0)------->0
NVL(0,100)---------->0
NVL(0,50)-------->0
NVL(50,100)------->50
NVL(100,50)-------->100

SQL> SELECT NVL(NULL,0) FROM DUAL;

NVL(NULL,0)
-----------
          0

SQL> SELECT ENAME,JOB,SAL,COMM,SAL+NVL(COMM,0) FROM EMP WHERE ENAME='SMITH';

ENAME      JOB              SAL       COMM SAL+NVL(COMM,0)
---------- --------- ---------- ---------- ---------------
SMITH      CLERK            800                        800


SQL> SELECT ENAME,JOB,SAL,COMM,SAL+NVL(COMM,100) FROM EMP WHERE ENAME='SMITH';

ENAME      JOB              SAL       COMM SAL+NVL(COMM,100)
---------- --------- ---------- ---------- -----------------
SMITH      CLERK            800                          900


SQL> SELECT ENAME,JOB,SAL,COMM,SAL+NVL(COMM,100) FROM EMP WHERE ENAME='ALLEN';

ENAME      JOB              SAL       COMM SAL+NVL(COMM,100)
---------- --------- ---------- ---------- -----------------
ALLEN      SALESMAN        1600        300              1900

NVL2(EXP1,EXP2,EXP3)
======================
-It is an extension of NVL()
-having 3 arguments

-if EXP1 is null ------------>returns ------------>EXP3 VALUE(USER DEFINED VALUE)

EX
==
NVL2(null,100,200)--------->200
SQL> SELECT NVL2(NULL,100,200) FROM DUAL;

-if EXP1 IS not null -----------> returns ------------->EXP2 VALUE(USER DEFINED VALUE)
NVL2(0,100,200)--------->100
NVL2(500,50,0)----------->50

ex
====
waq to update all employee commissions in a table based on the following conditions

i> if employee commission is null then update employee commission as 800
ii>if employee commission is not null then update employee commission as comm+300


SQL> UPDATE EMP SET COMM=NVL2(COMM,COMM+300,800);

14 rows updated.

LIKE:
=========
-comparing a specific string char pattern in a table.
-when we use like operator we should use the following
'wildcard operstors'

i> %    : it represent the remaining group of char's after selected char in the expression.
ii>_    : counting a single char in expression.


Ex
=====
    Ename 
    =====
    SAI
    SMITH
    suresh
    SCO

    ====================

Ex
=====
waq emp whose name starts with S

SQL> SELECT * FROM EMP WHERE ENAME LIKE 'S%';

sol:
==========
SELECT * FROM EMP WHERE ENAME LIKE 'S';//no result

waq to fetch employee details whose name is haing 3 chars?
sol : select * from emp where ename like'---';(sai,anu)

===================18===================================================


WHOSE NAME END WITH 'R'

SQL> SELECT * FROM EMP WHERE ENAME LIKE 'S%';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7788 SCOTT      ANALYST         7566 19-APR-87       3000                    20
      7369 SMITH      CLERK           7902 17-DEC-80        800                    20

SQL> SELECT * FROM EMP WHERE ENAME LIKE '%R';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30
      7934 MILLER     CLERK           7782 23-JAN-82       1300                    10


ex
====
to display employee whose name is having "i"?

SQL> SELECT * FROM EMP WHERE ENAME LIKE '%I%';

SQL> SELECT * FROM EMP WHERE ENAME LIKE '%I%';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7839 KING       PRESIDENT            17-NOV-81       5000                    10
      7369 SMITH      CLERK           7902 17-DEC-80        800                    20
      7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30
      7934 MILLER     CLERK           7782 23-JAN-82       1300                    10

ex=

whose name is having 4 chars ?

SQL> SELECT * FROM EMP WHERE ENAME LIKE '____';

SQL> SELECT * FROM EMP WHERE ENAME LIKE '____';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7839 KING       PRESIDENT            17-NOV-81       5000                    10
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30

SQL> SELECT * FROM EMP WHERE ENAME LIKE '_ _ _ _';

no rows selected

EX:
====
whose name 2nd char is 'O'?

SQL> SELECT * FROM EMP WHERE ENAME LIKE '_O%';

SQL> SELECT * FROM EMP WHERE ENAME LIKE '_O%';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7566 JONES      MANAGER         7839 02-APR-81       2975                    20
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20

ex
==
emp who are joined in 1981

SQL> SELECT * FROM EMP WHERE HIREDATE LIKE '%81';


SQL> SELECT * FROM EMP WHERE HIREDATE LIKE '%81';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7839 KING       PRESIDENT            17-NOV-81       5000                    10
      7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30
      7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
      7566 JONES      MANAGER         7839 02-APR-81       2975                    20
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30
      7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30
      7900 JAMES      CLERK           7698 03-DEC-81        950                    30

10 rows selected.

EX 
===
 to display employee who are joined in month of "december"?

SQL> SELECT * FROM EMP WHERE HIREDATE LIKE '%DEC%';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
      7369 SMITH      CLERK           7902 17-DEC-80        800                    20
      7900 JAMES      CLERK           7698 03-DEC-81        950                    30


LIKE OPERATOR WITH SPECIAL Character
===================================
SQL> SELECT * FROM TEST
  2  ;

       EID ENAME
---------- ----------
      1021 SMI_TH
      1022 ALL@EN
      1023 MI#LLER
      1024 _WARD
      1025 WAR%NER
      1026 ADAMS%

6 rows selected.

WHOSE NAME CONTAIN @

SQL> SELECT * FROM TEST WHERE ENAME LIKE '%@%';

       EID ENAME
---------- ----------


TO display employee whose name contain "#"?

SQL> SELECT * FROM TEST WHERE ENAME LIKE '%@%';

       EID ENAME
---------- ----------
      1022 ALL@EN

SQL> SELECT * FROM TEST WHERE ENAME LIKE '%#%';

       EID ENAME
---------- ----------
      1023 MI#LLER

whose name is having _ 
=============================   
whose name is having %

Note
========

-Generally "%,_" -------------------->by default "wildcard operators" but not special char's.
- treat as special char's then we use "escape '\'" statement.

SQL> SELECT * FROM TEST WHERE ENAME LIKE '%\_%' ESCAPE '\';

SQL> SELECT * FROM TEST WHERE ENAME LIKE '%\_%'ESCAPE'\';

       EID ENAME
---------- ----------
      1021 SMI_TH
      1024 _WARD

SQL> SELECT * FROM TEST WHERE ENAME LIKE '%\%%'ESCAPE'\';

       EID ENAME
---------- ----------
      1025 WAR%NER
      1026 ADAMS%

SQL> SELECT * FROM EMP WHERE ENAME  NOT LIKE 'S%';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7839 KING       PRESIDENT            17-NOV-81       5000                    10
      7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30
      7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
      7566 JONES      MANAGER         7839 02-APR-81       2975                    20
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30
      7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30
      7876 ADAMS      CLERK           7788 23-MAY-87       1100                    20
      7900 JAMES      CLERK           7698 03-DEC-81        950                    30
      7934 MILLER     CLERK           7782 23-JAN-82       1300                    10

12 rows selected.

FUNCTIONS
===========
-To perform some task and return some value.
    1. Pre-defined FUNCTIONS
            -use in SQL & PL/SQL.
    2. User-defined FUNCTIONS
            -by using PL/SQL.

1.Pre-defined FUNCTIONS
==========================
    i)Single row function(scalar finction)
    ii)multiple row functions(grouping functions)

i)single row function(scalar functions)
=======================================
-return a single value.
        i)numeric functions
        ii)string functions
        iii)date functions
        iv)conversion functions
        v)general functions

syntax to call a function
==========================
Select <fname>(values) from dual;

What is Dual?
==============
    -pre-defined/system defined table.
    -having only one row & one column.
    -used to test functions functionalites.
    -is also called as "Dummy table" in oracle.

Ex:
Desc dual;
select * from dual;


i)numeric functions
========================
ABS()
=====
    -to convert(-ve) sign values into (+ve) sign values.

syntax
========
abs(number)


SQL> SELECT ENAME,SAL,COMM,ABS(COMM-SAL) FROM EMP;

SQL> SELECT ENAME,SAL,COMM,ABS(COMM-SAL) FROM EMP;

SQL> SELECT ABS(-12) FROM DUAL;

  ABS(-12)
----------
        12

==================================================================================
CEIL():
=======
    - return a value which is more than or equal to the given expression.

syntax
======
    ceil(number)

ex
====
SLECT CEIL(9.3) FROM DUAL;

SQL> SELECT CEIL(9.3) FROM DUAL;

CEIL(9.3)
----------
         10

SQL> SELECT CEIL(-9.3) FROM DUAL;

CEIL(-9.3)
-----------
         -9

FLOOR()
=========
    -return a value which is less than or equal to the given expression.

syntax
======
    floor(number)

ex
====
SLECT FLOOR(9.3) FROM DUAL;

SQL> SELECT FLOOR(9.3) FROM DUAL;

FLOOR(9.3)
-----------
         9

SQL> SELECT FLOOR(-9.3) FROM DUAL;

FLOOR(-9.3)
------------
         -10


MOD():
    - return reminder value from a given expression

syntax
==========
    mod(number1,number2)

ex
==
SQL> SELECT MOD(10,2) FROM DUAL;

 MOD(10,2)
----------
         0

POWER()
==========
    -return power of given expression

SQL> SELECT POWER(2,3) FROM DUAL;

POWER(2,3)
----------
         8

ROUND()
============
    -return the nearest value of the given expression.

syntax
-----------
    round(number,digit)


SQL> SELECT ROUND(34.45) FROM DUAL;

ROUND(34.45)
------------
          34

SQL> SELECT ROUND(34.50) FROM DUAL;

ROUND(34.50)
------------
          35

SQL> SELECT ROUND(34.45) FROM DUAL;

ROUND(34.45)
------------
          34

SQL> SELECT ROUND(34.50) FROM DUAL;

ROUND(34.50)
------------
          35


TRUNC()
==========
    -return the exact value from given expression.

syntax
========
trunc


SQL> SELECT TRUNC(34.45) FROM DUAL;

TRUNC(34.45)
------------
          34

SQL> SELECT TRUNC(34.45) FROM DUAL;

TRUNC(34.45)
------------
          34

SQL> SELECT TRUNC(34.50) FROM DUAL;

TRUNC(34.50)
------------
          34

SQL> SELECT TRUNC(34.60) FROM DUAL;

TRUNC(34.60)
------------
          34


STRING FUNCTIONS
================

LENGTH():
=============
        -return length of given string.


syntax
===========
    length(string)

SQL> SELECT LENGTH('HELLO') FROM DUAL;

LENGTH('HELLO')
---------------
              5

SQL> SELECT LENGTH('WEL COME') FROM DUAL;

LENGTH('WELCOME')
-----------------
                8

LOWER()
==========
    -to convert upper case char's into lower case char's.

SQL> SELECT LOWER('HELLO') FROM DUAL;

LOWER
-----
hello

UPPER()
==========
    -to convert lower case char's into upper case char's.

INITCAP()
==========
    - to convert first char is capital in the expression.

syntax
=======

SQL> SELECT INITCAP('welcome') from DUAL;

INITCAP
-------
Welcome

SQL> SELECT INITCAP('HELLO') FROM DUAL;

INITC
-----
Hello

20=====================================
================================================================================================
LTRIM() & RTRIM()
=========================
LTRIM() - to remove unwanted chars/spaces from left side of given string.
RTRIM() - to remove unwanted chars/spaces from right side of given string.


syntax
=======
ltrim(String1,[string2])
rtrim(string1,[string2])


TRIM():
========
-COMBINATION OF LTRIM() & RTRIM()
-to remove unwanted characters and spaces from both side of a given string.

syntax
=========
trim('trimming char' from string)

LPAD() & RPAD()
===================
    LPAD() : filling a string with a specific char on left side of given string.
    RPAD() : filling a string with a specific char on right side of given string.

syntax
====
lpad(string1,length,string2)
rpad(string1,length,string2)

ex
=========
SQL> SELECT TRIM('X' FROM 'XXXXSAIXXX') FROM DUAL;

TRI
---
SAI

SQL> SELECT LPAD('HELLO',3) FROM DUAL;

LPA
---
HEL

SQL> SELECT LPAD('HELLO',10) FROM DUAL;

LPAD('HELL
----------
     HELLO

SQL> SELECT LPAD('HELLO',10,'@') FROM DUAL;

LPAD('HELL
----------
@@@@@HELLO

SQL> SELECT RPAD('HELLO',10,'$') FROM DUAL;


CONCAT():
=================
    -adding two string expressions

    SQL> SELECT CONCAT('GOOD','AFTERNOON') FROM DUAL;

CONCAT('GOOD'
-------------
GOODAFTERNOON


REPLACE()
=============
-to replace one string with another string

replace(string1,string2,str3);
============================
SQL> SELECT REPLACE('HELLO','ELL','AB') FROM  DUAL;

REPL
----
HABO

TRANSLATE()
============
- to translate a single char by char.

syntax
--------
translate(string1,string2,string3);


SQL> SELECT TRANSLATE('HELLO','ELO','XYZ') FROM DUAL;

TRANS
-----
HXYYZ

SUBSTR()
========
- returns the required sub string from a given expression.

syntax
---------
substr(string1,<starting position of char>,<length of char's>) 

SQL> SELECT SUBSTR('WELCOME',3,2) FROM DUAL;

SU
--
LC


INSTR()
======
-return the occurance position of character in the given string expression.


Syntax
======
instr(string1,string2,<starting postion of char>,<occurance postion of char>)

ex:
====
SQL> SELECT INSTR('HELLO WELCOME','O') FROM DUAL;

INSTR('HELLOWELCOME','O')
-------------------------
                        5

SQL> SELECT INSTR('HELLO WELCOME','O',1,1) FROM DUAL;

INSTR('HELLOWELCOME','O',1,1)
-----------------------------
                            5

SQL> SELECT INSTR('HELLO WELCOME','O',1,2) FROM DUAL;

INSTR('HELLOWELCOME','O',1,2)
-----------------------------
                           11
SQL> SELECT INSTR('HELLO WELCOME','E',1,3) FROM DUAL;

INSTR('HELLOWELCOME','E',1,3)
-----------------------------
                           13

SQL> SELECT INSTR('HELLO WELCOME','E',1,4) FROM DUAL;

INSTR('HELLOWELCOME','E',1,4)
-----------------------------
                            0

SQL> SELECT INSTR('HELLO WELCOME','E',-1,3) FROM DUAL;

INSTR('HELLOWELCOME','E',-1,3)
------------------------------
                             2
=postion of char's in the string expression is always fixed either count from
left to right or right to left.

DATE FUNCTIONS
===========
SYSDATE:
--------
-Return the current date information of the system.
SQL> SELECT SYSDATE FROM DUAL;

SYSDATE
---------
18-JAN-26


ADD_MONTHS()
===========
-add no of months to the given date expression.

syntax
=======
add_months(date1,<no. of months>)

SQL> SELECT ADD_MONTHS(SYSDATE,3) FROM DUAL;

ADD_MONTHS(SYSDATE,3)       

SQL> SELECT ADD_MONTHS(SYSDATE,5) FROM DUAL;

ADD_MONTH
---------
20-JUN-26

SQL> SELECT ADD_MONTHS(SYSDATE,-5) FROM DUAL;

ADD_MONTH
---------
20-AUG-25

LAST_DAY()
==========
    -return last day of the given month in date expression.


SQL> SELECT LAST_DAY(SYSDATE) FROM DUAL;

MONTHS_BETWEEN()
------------------
-return no.of months between the given two date expressions.

syntax
-------
months_between(date1,date2)

SQL> SELECT MONTHS_BETWEEN(SYSDATE,HIREDATE) FROM EMP;

SQL> SELECT MONTHS_BETWEEN(SYSDATE,HIREDATE) FROM EMP;

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPT         



SQL> SELECT MONTHS_BETWEEN('07-OCT-21','07-OCT-22') FROM DUAL;

MONTHS_BETWEEN('07-OCT-21','07-OCT-22')
---------------------------------------
                                    -12


NOTE
========
-HERE DATE1 EXPRESSION IS ALWAYS GREATER THAN DATE 2 otherwise it return negative value.


SQL> SELECT MONTHS_BETWEEN('07-OCT-22','07-OCT-21') FROM DUAL;

MONTHS_BETWEEN('07-OCT-22','07-OCT-21')
---------------------------------------
                                     12


CONVERSION FUNCTIONS
======================

i> to_char()
ii> to_date()

i>to_char()
============
to convert date type to char type and display date expression in different format.

syntax
==========

to_char(date,<interval format>)


ex:
====
Year format
==========
SQL> SELECT TO_CHAR(SYSDATE,'YYYY') FROM DUAL;

ex
======
year format
============
YYYY- four digits of the year(2021)
YY- LAST TWO digits of the year(21)
YEAR-TWENTY TWENTY FIVE
CC-CENTYRY
AD/BC- AD year/ BC year

SQL> SELECT TO_CHAR(SYSDATE,'YYYY') FROM DUAL;

TO_CHAR(SYSDATE,'YYYY')
-----------------------
2021

SQL> SELECT TO_CHAR(SYSDATE,'YY') FROM DUAL;

TO_CHAR(SYSDATE,'YY')
---------------------
21                  

SQL> SELECT TO_CHAR(SYSDATE,'YYYY YY YEAR CC BC' ) FROM DUAL;

TO_CHAR(SYSDATE,'YYYYYYYEARCCBC')
--------------------------------------------------------
2026 26 TWENTY TWENTY-SIX 21 AD

SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'YYYY')=1982;

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7934 MILLER     CLERK           7782 23-JAN-82       1300                    10

SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'YYYY')=82;

no rows selected

SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'YY')=1982;

no rows selected

SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'YY')=82;

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7934 MILLER     CLERK           7782 23-JAN-82       1300                    10


MONTH FORMAT
============
MM - MONTH number
MON - FIRST THREE CHARS FROM MONTH SPELLING
MONTH- FULL NAME OF MONTH

SQL> SELECT TO_CHAR(SYSDATE,'MM') FROM DUAL;

TO_CHAR(SYSDATE,'MM')
---------------------
01

SQL> SELECT TO_CHAR(SYSDATE,'MON') FROM DUAL;

TO_CHAR(SYSDATE,'MON')
---------------------
JAN

SQL> SELECT TO_CHAR(SYSDATE,'MONTH') FROM DUAL;

TO_CHAR(SYSDATE,'MONTH')
-------------------------
JANUARY

SQL> SELECT TO_CHAR(SYSDATE,'MM MON MONTH') FROM DUAL;

TO_CHAR(SYSDATE,'MMMONMONTH')
----------------------------------------------------
01 JAN JANUARY


SQL> SELECT TO_CHAR(SYSDATE,'MM MON MONTH') FROM DUAL;

TO_CHAR(SYSDATE,'MMMONMONTH')
----------------------------------------------------
01 JAN JANUARY

SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'MM') IN(02,06,12);

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
      7369 SMITH      CLERK           7902 17-DEC-80        800                    20
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30
      7900 JAMES      CLERK           7698 03-DEC-81        950                    30

6 rows selected.


SQL> SELECT TO_CHAR(SYSDATE,'MM MON MONTH') FROM DUAL;

TO_CHAR(SYSDATE,'MMMONMONTH')
----------------------------------------------------
01 JAN JANUARY


DAY FORMAT
=========
DDD -  DAY OF THE YEAR
DD  -  DAY OF THE MONTH
D   -  DAY OF THE WEEK

SUN-1
MON-2
TUE-3
WED-4
THU-5
FRI-6
SAT-7

SQL> SELECT TO_CHAR(SYSDATE,'DDD') FROM DUAL;

TO_CHAR(SYSDATE,'DD') FROM DUAL;

TO_CHAR(SYSDATE,'D') FROM DUAL;

TO_CHAR(SYSDATE,'DD')       


DAY - full name of the day
DY- FIRST 3 CHAR OF DAY SPELLING

EX
====
SELECT TO_CHAR



SQL> SELECT TO_CHAR(SYSDATE,'DDD DD D DAY DY') FROM DUAL;

TO_CHAR(SYSDATE,'DDDDDDDAYDY')
----------------------------------------------------------
020 20 3 TUESDAY   TUE


QUATER FORMAT
=============
Q- ONE DIGIT QUATER OF THE YEAR

1= JAN-MAR
2= APR-JUN
3-JUL-SEP
4-OCT-DEC

SQL> SELECT TO_CHAR(SYSDATE,'Q') FROM DUAL;

SQL> SELECT TO_CHAR(SYSDATE,'Q') FROM DUAL;

T
-
1

SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'YYYY')=1981;

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7839 KING       PRESIDENT            17-NOV-81       5000                    10
      7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30
      7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
      7566 JONES      MANAGER         7839 02-APR-81       2975                    20
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30
      7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30
      7900 JAMES      CLERK           7698 03-DEC-81        950                    30

10 rows selected.

SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'YYYY')=1981 AND TO_CHAR(HIREDATE,'Q')=2;

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30
      7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
      7566 JONES      MANAGER         7839 02-APR-81       2975                    20

WEEK FORMAT
============
WW - WEEK IN THE YEAR
W - WEEK IN THE MONTH

SQL> SELECT TO_CHAR(SYSDATE,'WW W') FROM DUAL;

TO_C
----
03 3

TIME FORMAT
================
HH24 - 24HR FORMAT
HH12 - 12HR FORMAT
MI - MINUTE
SS- SECONDS


SQL> SELECT TO_CHAR(SYSDATE,'HH24 HH12 MI SS AM') FROM DUAL;

TO_CHAR(SYSDAT
--------------
07 07 40 45 AM

TO_DATE()
==========
-to convert char type to oracle default date format(dd-mon-yy)

to_date(string)

ex
==
SELECT TO_DATE('08/AUGUST/2020') FROM DUAL;


MULTIPLE ROW FUNCTIONS
=======================
-return either single value or group of values and return a single value.
-is also called as "grouping functions"

sum()
=======
return sum of values

AVG()
======
-return average of employee

SQL> SELECT SUM(SAL) FROM EMP;

  SUM(SAL)
----------
     29025

SQL> SELECT * FROM EMP WHERE JOB='ANALYST';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7788 SCOTT      ANALYST         7566 19-APR-87       3000                    20
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20

SQL> SELECT SUM(SAL) FROM EMP WHERE JOB='ANALYST';

  SUM(SAL)
----------
      6000

SQL> SELECT AVG(SAL) FROM EMP;

  AVG(SAL)
----------
2073.21429

SQL> SELECT * FROM EMP WHERE DEPTNO=10;

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7839 KING       PRESIDENT            17-NOV-81       5000                    10
      7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
      7934 MILLER     CLERK           7782 23-JAN-82       1300                    10

SQL> SELECT SUM(SAL) FROM EMP WHERE DEPTNO=10;

  SUM(SAL)
----------



SQL> SELECT AVG(SAL) FROM EMP WHERE DEPTNO=10;

  AVG(SAL)
----------
2916.66667

2>AVG()
3>MIN()
========
-return minimum value

MAX()
=====
it returns maximum value


COUNT(*)
return all rows values including null and duplicates

SQL> SELECT * FROM TEST;

       SNO NAME
---------- ----------
       101 AA
       102 BB
       103 CC
       104
       105 AA
       106 CC

6 rows selected.

SQL> select count(*) from test
  2  ;

  COUNT(*)
----------
         6
COUNT(<COLUMN NAME>)

counting all values in a column except nulls;

SQL> select count(NAME) from test;

COUNT(NAME)
-----------
          5
COUNT(DISTINCT<COULMN NAME>)
--------------------------------------
-counting unique values in a column.

SQL> SELECT COUNT(DISTINCT NAME) FROM TEST;

COUNT(DISTINCTNAME)
-------------------
                  
                  ==22==========

    
CLAUSES
=========
-it is a statement which is used to add to sql query for providing the additional facilities are
"filtering rows,Sorting values,grouping similar data,Finding sub total and grand total" based on
columns autimatically.


syntax
=========
<SQL Query> +<Clause statement>

-where-Order by
-Group by
-having
-RollUp
-Cube

ex-WAQ TO rerive employee details whose empno is 7788?
sol:
select * from emp;-------------without where clause condition.
select * from emp + where empno=7788;
    ||                  ||

    sql squery          clauses



where
=========
-filtering rows one-by-one manner before grouping data in a table.
-can be used in "SELECT,UPDATE,DELETE" command only.



syntax
=========
        where <filtering condition>

ex:
select * from emp where empno=7788;
update emp set sal=4400 where jpb='clerk';
delete from emp where dept=10;

Order by
==============
    -sorting values of a column(ascending/descending )
    -by default order by clause arrange values in ascending order only.
     but if we want to arrange values in descending order ------->"desc" keyword.

     -Desc<table name> ----------->Desc = Describe
     -Desc<column name>------------->Desc = Descending
    -it can be used only "SELECT" command only.


syntax
============
select * from <table name> order by <column name1><asc|desc>,<column name2><asc|desc>..............................;


SQL> SELECT * FROM EMP ORDER BY SAL;

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7369 SMITH      CLERK           7902 17-DEC-80        800                    20
      7900 JAMES      CLERK           7698 03-DEC-81        950                    30
      7876 ADAMS      CLERK           7788 23-MAY-87       1100                    20
      7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30
      7934 MILLER     CLERK           7782 23-JAN-82       1300                    10
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
      7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
      7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30
      7566 JONES      MANAGER         7839 02-APR-81       2975                    20
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
      7788 SCOTT      ANALYST         7566 19-APR-87       3000                    20
      7839 KING       PRESIDENT            17-NOV-81       5000                    10

SQL> SELECT HIREDATE FROM EMP ORDER BY HIREDATE DESC;

SQL> SELECT HIREDATE FROM EMP ORDER BY HIREDATE DESC;


ex
=====
waq to display list of employee who are working under dept=20 and arrange those employee salaries in descending order?

SELECT * FROM EMP WHERE DEPTNO=20 ORDER BY SAL DESC;


waq to arrange employee dept nos in ascending no and and those employee salaries in descending order for each dept no wise?

SQL> SELECT * FROM EMP ORDER BY DEPTNO,SAL DESC;

Note
======
    - using orderby clause on not only column names even though we can apply order by clause on position of column in select query.

    SQL> SELECT * FROM EMP ORDER BY 6;
SQL> SELECT EMPNO,ENAME FROM EMP ORDER BY 1 DESC;

Order by with Null clauses
=============================
    i>nulls first
    ii>nulls last

  SQL> SELECT * FROM EMP ORDER BY COMM NULLS FIRST;

       EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
  ---------- ---------- --------- ---------- --------- ---------- ---------- ----------
        7839 KING       PRESIDENT            17-NOV-81       5000                    10
        7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30
        7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
        7566 JONES      MANAGER         7839 02-APR-81       2975                    20
        7788 SCOTT      ANALYST         7566 19-APR-87       3000                    20
        7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
        7934 MILLER     CLERK           7782 23-JAN-82       1300                    10
        7369 SMITH      CLERK           7902 17-DEC-80        800                    20
        7900 JAMES      CLERK           7698 03-DEC-81        950                    30
        7876 ADAMS      CLERK           7788 23-MAY-87       1100                    20
        7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30
        7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
        7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30
        7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30

  14 rows selected.


  SQL> SELECT * FROM EMP ORDER BY COMM DESC NULLS LAST;

       EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO
  ---------- ---------- --------- ---------- --------- ---------- ---------- ----------
        7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30
        7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30
        7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
        7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30
        7788 SCOTT      ANALYST         7566 19-APR-87       3000                    20
        7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
        7934 MILLER     CLERK           7782 23-JAN-82       1300                    10
        7876 ADAMS      CLERK           7788 23-MAY-87       1100                    20
        7900 JAMES      CLERK           7698 03-DEC-81        950                    30
        7566 JONES      MANAGER         7839 02-APR-81       2975                    20
        7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10
        7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30
        7839 KING       PRESIDENT            17-NOV-81       5000                    10
        7369 SMITH      CLERK           7902 17-DEC-80        800                    20

  14 rows selected.


NOTE : these are optional.

Group by:
============
    - grouping similar data based on columns.
    -when we use group by clause we should use "grouping functions" are "count(),sum(),avg(),min(),max()";
    -use in "select command only".


 syntax
 ========
 select <column name1>,<column name2>,.......<grouping function name1>,...... from
 <table name> group by (<column name1>,<column name2>,..........);

 Ex:
 ====
 waq to find out no.of employee working in each dept wise ?

 SQL> SELECT DEPTNO,COUNT(*) FROM EMP GROUP BY DEPTNO;

     DEPTNO   COUNT(*)
 ---------- ----------
         30          6
         10          3
         20          5

   SQL> SELECT DEPTNO,COUNT(*) FROM EMP GROUP BY DEPTNO ORDER BY DEPTNO;

       DEPTNO   COUNT(*)
   ---------- ----------
           10          3
           20          5
           30          6

    EX
    ===
    waq to display sum of salaries of each job wise ?

    SQL> SELECT JOB,SUM(SAL) FROM EMP GROUP BY JOB;

    JOB         SUM(SAL)
    --------- ----------
    ANALYST         6000
    CLERK           4150
    SALESMAN        5600
    MANAGER         8275
    PRESIDENT       5000


SQL> SELECT DEPTNO,COUNT(*) NO_OF_EMP,SUM(SAL) TOTAL_SAL,AVG(SAL) AVG_SAL,MIN(SAL) MIN_SAL,MAX(SAL) MAX_SAL FROM EMP GROUP BY DEPTNO;

    DEPTNO  NO_OF_EMP  TOTAL_SAL    AVG_SAL    MIN_SAL    MAX_SAL
---------- ---------- ---------- ---------- ---------- ----------
        30          6       9400 1566.66667        950       2850
        10          3       8750 2916.66667       1300       5000
        20          5      10875       2175        800       3000


  HAVING
  ==========
  -to filtering rows after grouping data in table
  -this clause can be used along with group by clause.


syntax
=======
 select <column name1>,<column name2>,.......<grouping function name1>,...... from
 <table name> group by (<column name1>,<column name2>,..........) having <filtering vondition>


waq to display deptno's in which deptno no of employee is more than 3 ?

SELECT DEPTNO,COUNT(*) FROM EMP GROUP BY DEPTNO ORDER BY DEPTNO;


SQL> SELECT DEPTNO,COUNT(*) FROM EMP GROUP BY DEPTNO HAVING COUNT(*)>3;

    DEPTNO   COUNT(*)
---------- ----------
        30          6
        20          5

SQL> SELECT DEPTNO,COUNT(*) FROM EMP GROUP BY DEPTNO HAVING COUNT(*)>3 ORDER BY DEPTNO;

    DEPTNO   COUNT(*)
---------- ----------
        20          5
        30          6


  WAQ TO DISPLAY JOBS in which job sum of salary less than 5000 ?

  SQL> SELECT JOB,SUM(SAL) FROM EMP GROUP BY JOB HAVING SUM(SAL)<5000;

  JOB         SUM(SAL)
  --------- ----------
  CLERK           4150


All classes in a single select query:
=====================================
syntax:
=========
select<column name>,......<grouping function name>,...... from <table name>
[where<filtering condition>
group by<coloumn name>
having<filtering condition>
order by<column name><asc|desc>
]
SQL> SELECT DEPTNO,COUNT(*) FROM EMP
  2  WHERE SAL>1000
  3  GROUP BY DEPTNO
  4  HAVING COUNT(*)>3
  5  ORDER BY DEPTNO;

    DEPTNO   COUNT(*)
---------- ----------
        20          4
        30          5


 Order of execution
 ===================
 -FROM
 -WHERE
 -GROUP BY
 -HAVING
 -SELECT
 -ORDER BY


 ROLLUP & CUBE
 ==================
 -are sepecial clauses
 -to finding sub total and grand total based on columns
 -are implementing along with "group by"
        -Rollup: to find sub total & grand total based on a single columns.
        -Cube : to find sub total & grand total based on multiple columns.

 syntax for Rollup
 =================


select<column name>,......<grouping function name>,...... from <table name>
[where<filtering condition>
group by rollup<coloumn name1>,<column name2>,............);
                    ||                      ||
                operational column      supporting column
                to find sub & grand
                total

 rollup with single Column
 =========================
 SQL> SELECT DEPTNO,COUNT(*) FROM EMP
   2  GROUP BY ROLLUP(DEPTNO)
   3  ;

     DEPTNO   COUNT(*)
 ---------- ----------
         10          3
         20          5
         30          6
                    14

 ROLLUP WITH MULTIPLE COLUMNS
 =======================================
 SQL> SELECT JOB,DEPTNO,COUNT(*) FROM EMP GROUP BY ROLLUP(JOB,DEPTNO);

 JOB           DEPTNO   COUNT(*)
 --------- ---------- ----------
 CLERK             10          1
 CLERK             20          2
 CLERK             30          1
 CLERK                         4
 ANALYST           20          2
 ANALYST                       2
 MANAGER           10          1
 MANAGER           20          1
 MANAGER           30          1
 MANAGER                       3
 SALESMAN          30          4
 SALESMAN                      4
 PRESIDENT         10          1
 PRESIDENT                     1
                              14

 15 rows selected.



 syntax for CUBE
 =================


select<column name>,......<grouping function name>,...... from <table name>
[where<filtering condition>
group by cube<coloumn name1>,<column name2>,............);
             ==========================================
                        ||
                all columns are operational column
                to find sub & grand
                total


  GROUPING_ID()
  ================
  -to give id numbers to sub total rows & grand total row in result set.

        id number 1 : first sub total row
        id number 2 : second subtotal row
        id number 3 : grand row


JOINS
=========
-are used to retrieve data from multiple tables at a time.
-joins can be use in two ways,

1. Non-ansi format joins(oracle 8i joins)
===========================================
    -Equi join
    -Non Equi join
    -Self join


2.Ansi format joins(oracle 9i joins)
===================================
    -Inner join
    -Outer join
            -left outer
            -right outer
            -full outer
     -cross join/cartesian join
     -Natural join



Note
========
1.when we retrieve data from multiple tables based on "where" clause condition
then we called as "Non-ansi joins".

2.when we retrieve data from multiple tables with "ON" clause condition
  then we called as "Non-ansi joins".

3.Non-ansi joins are not a portablity where as Ansi joins are portability where portablity measns we can move join statement from one database
to other database without any changes as it is we can move it.

syntax for non-ani joins
===========================
select * from <table name1>,<table name2> where <joining condition>

syntax for ANSI joins
=====================
select * from <table name1> <join key> <table name2> on <joining condition>


Equi join
============
        -when we retrieve data from multiple tables based on an "=" operator.
        -we have at least a single common column(optional) in both tables.

        test1   test2   test3   test4
        ===      ====   ====    ====

        -is always retreve matching rows/data from multiple tables.
        -when we joins on tables is it need to have relationship between tables ?
            ans-optional[yes|no][may be | maynot be]

syntax
=======
    where <table name1><common column>= <table name2>.<common column>

    or

    where<table name1 alias name>.<column name>=<table name2 alias name>.<column name>

SQL> SELECT * FROM STUDENT;

      STID SNAME             CID
---------- ---------- ----------
      1021 SMITH              10
      1022 ALLEN              20
      1023 MILLER             30

SQL> SELECT * FROM COURSE;

       CID CNAME            CFEE
---------- ---------- ----------
        10 C                1000
        20 ORACLE           2500
        40 JAVA             5000

waq to retrieve student and their course details from student,course tables by using equi join ?
=================================================================================================
SQL> SELECT * FROM STUDENT,COURSE WHERE STUDENT.CID=COURSE.CID;

      STID SNAME             CID        CID CNAME            CFEE
---------- ---------- ---------- ---------- ---------- ----------
      1021 SMITH              10         10 C                1000
      1022 ALLEN              20         20 ORACLE           2500
SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID=C.CID;

      STID SNAME             CID        CID CNAME            CFEE
---------- ---------- ---------- ---------- ---------- ----------
      1021 SMITH              10         10 C                1000
      1022 ALLEN              20         20 ORACLE           2500

Rule of joins
=============
    -a row in a table is comparing with all rows in another table.

 waq to retrieve student ,course details from tables by using equi join if course id is 20 ?

===============================================================================================
SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID=C.CID AND S.CID=20;

      STID SNAME             CID        CID CNAME            CFEE
---------- ---------- ---------- ---------- ---------- ----------
      1022 ALLEN              20         20 ORACLE           2500

SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID=C.CID AND C.CID=20;

      STID SNAME             CID        CID CNAME            CFEE
---------- ---------- ---------- ---------- ---------- ----------
      1022 ALLEN              20         20 ORACLE           2500



waq to display employee from emp,dept tables who are working in the location "chicago"?
=======================================================================================
SQL> SELECT * FROM EMP E,DEPT D WHERE E.DEPTNO=D.DEPTNO AND LOC='CHICAGO';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO     DEPTNO DNAME          LOC
---------- ---------- --------- ---------- --------- ---------- ---------- ---------- ---------- -------------- -------------
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30         30 SALES          CHICAGO
      7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30         30 SALES          CHICAGO
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30         30 SALES          CHICAGO
      7900 JAMES      CLERK           7698 03-DEC-81        950                    30         30 SALES          CHICAGO
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30         30 SALES          CHICAGO
      7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30         30 SALES          CHICAGO

6 rows selected.


Inner join
==========
-is similar to equi join.
-it is ANSI format.

waq to retrieve student and their course details from student,course tables by using inner join ?


SQL> SELECT * FROM STUDENT S INNER JOIN COURSE C ON S.CID=C.CID;

      STID SNAME             CID        CID CNAME            CFEE
---------- ---------- ---------- ---------- ---------- ----------
      1021 SMITH              10         10 C                1000
      1022 ALLEN              20         20 ORACLE           2500



SQL> SELECT * FROM EMP E INNER JOIN DEPT D ON E.DEPTNO=D.DEPTNO AND LOC='CHICAGO';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM     DEPTNO     DEPTNO DNAME          LOC
---------- ---------- --------- ---------- --------- ---------- ---------- ---------- ---------- -------------- -------------
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30         30 SALES          CHICAGO
      7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30         30 SALES          CHICAGO
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30         30 SALES          CHICAGO
      7900 JAMES      CLERK           7698 03-DEC-81        950                    30         30 SALES          CHICAGO
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30         30 SALES          CHICAGO
      7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30         30 SALES          CHICAGO

NOTE:
=========
    -equi/inner join retrieving only matching data from tables.

OUTER JOINS
============
    I)left outer join
    =====================
            -retrieving matching data from both tables and unmatching data from left side only.


       ex:
       ANSI
       ======
       SQL> SELECT * FROM STUDENT S LEFT OUTER JOIN COURSE C ON S.CID=C.CID;

             STID SNAME             CID        CID CNAME            CFEE
       ---------- ---------- ---------- ---------- ---------- ----------
             1021 SMITH              10         10 C                1000
             1022 ALLEN              20         20 ORACLE           2500
             1023 MILLER             30

       NON-ANSI
       ========
            -when we write outer join statements in non-ansi format then we should use a join operator is called as (+)
            operator as(+)
            SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID=C.CID(+);

                  STID SNAME             CID        CID CNAME            CFEE
            ---------- ---------- ---------- ---------- ---------- ----------
                  1021 SMITH              10         10 C                1000
                  1022 ALLEN              20         20 ORACLE           2500
                  1023 MILLER             30

    ii)right outer join
    =======================
            -retrieving matching data from both the tables and unmatching data from RIGHT side table only.

            ANSI:
            SQL> SELECT * FROM STUDENT S RIGHT OUTER JOIN COURSE C ON S.CID=C.CID;

                  STID SNAME             CID        CID CNAME            CFEE
            ---------- ---------- ---------- ---------- ---------- ----------
                  1021 SMITH              10         10 C                1000
                  1022 ALLEN              20         20 ORACLE           2500
                                                     40 JAVA             5000
            NON ANSI:

SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID(+)=C.CID;

      STID SNAME             CID        CID CNAME            CFEE
---------- ---------- ---------- ---------- ---------- ----------
      1021 SMITH              10         10 C                1000
      1022 ALLEN              20         20 ORACLE           2500
                                         40 JAVA             5000

    iii)full outer join
    =====================
        -retrieving matching & also unmatching data from both tables.
        -is a combination of left outer and right outer.

       ANSI
       =======
        SQL> SELECT * FROM STUDENT S FULL OUTER JOIN COURSE C ON S.CID=C.CID;

              STID SNAME             CID        CID CNAME            CFEE
        ---------- ---------- ---------- ---------- ---------- ----------
              1021 SMITH              10         10 C                1000
              1022 ALLEN              20         20 ORACLE           2500
              1023 MILLER             30
                                                 40 JAVA             5000

       NON-ANSI
       =======

        SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID=C.CID(+)
          2  UNION
          3  SELECT * FROM STUDENT S,COURSE C WHERE S.CID(+)=C.CID;

              STID SNAME             CID        CID CNAME            CFEE
        ---------- ---------- ---------- ---------- ---------- ----------
              1021 SMITH              10         10 C                1000
              1022 ALLEN              20         20 ORACLE           2500
              1023 MILLER             30
                                                 40 JAVA             5000

        NON-EQUI JOIN:
        ================
            -retrieving data from multiple tables based on any condition except an "=" operator condition.
            -can use the following operators "<,>,<=,>=,!=,and,or,between,..............etc"


     ex
     ==
     SQL> SELECT * FROM TEST1;

            SNO NAME
     ---------- ----------
             10 SAI
             20 ADAM

     SQL> SELECT * FROM TEST2;

            SNO        SAL
     ---------- ----------
             10      15000
             30      25000
     SQL> SELECT * FROM TEST1 T1,TEST2 T2 WHERE T1.SNO >T2.SNO;

            SNO NAME              SNO        SAL
     ---------- ---------- ---------- ----------
             20 ADAM               10      15000


ex
====
waq to display employee whose salary is between low salary and high salary ?
SQL> SELECT ENAME,SAL,LOSAL,HISAL FROM EMP,SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL;

ENAME             SAL      LOSAL      HISAL
---------- ---------- ---------- ----------
SMITH             800        700       1200
JAMES             950        700       1200
ADAMS            1100        700       1200
MARTIN           1250       1201       1400
WARD             1250       1201       1400
MILLER           1300       1201       1400
TURNER           1500       1401       2000
ALLEN            1600       1401       2000
CLARK            2450       2001       3000
BLAKE            2850       2001       3000
JONES            2975       2001       3000
FORD             3000       2001       3000
SCOTT            3000       2001       3000
KING             5000       3001       9999

14 rows selected.

SQL> SELECT ENAME,SAL,LOSAL,HISAL FROM EMP,SALGRADE WHERE (SAL>=LOSAL) AND (SAL<=HISAL);

ENAME             SAL      LOSAL      HISAL
---------- ---------- ---------- ----------
SMITH             800        700       1200
JAMES             950        700       1200
ADAMS            1100        700       1200

ANSI FORMAT
===========

SQL> SELECT ENAME,SAL,LOSAL,HISAL FROM EMP JOIN SALGRADE ON SAL BETWEEN LOSAL AND HISAL;

ENAME             SAL      LOSAL      HISAL
---------- ---------- ---------- ----------
SMITH             800        700       1200
JAMES             950        700       1200
ADAMS            1100        700       1200
MARTIN           1250       1201       1400
WARD             1250       1201       1400
MILLER           1300       1201       1400
TURNER           1500       1401       2000
ALLEN            1600       1401       2000
CLARK            2450       2001       3000
BLAKE            2850       2001       3000
JONES            2975       2001       3000
FORD             3000       2001       3000
SCOTT            3000       2001       3000
KING             5000       3001       9999

14 rows selected.


SQL> SELECT ENAME,SAL,LOSAL,HISAL FROM EMP JOIN SALGRADE ON (SAL>=LOSAL) AND (SAL<=HISAL);

ENAME             SAL      LOSAL      HISAL
---------- ---------- ---------- ----------
SMITH             800        700       1200
JAMES             950        700       1200
ADAMS            1100        700       1200
MARTIN           1250       1201       1400
WARD             1250       1201       1400
MILLER           1300       1201       1400
TURNER           1500       1401       2000
ALLEN            1600       1401       2000
CLARK            2450       2001       3000
BLAKE            2850       2001       3000
JONES            2975       2001       3000
FORD             3000       2001       3000
SCOTT            3000       2001       3000
KING             5000       3001       9999

14 rows selected.

CROSS JOIN | CARTISEAN JOIN
==============================
-joining tables without any condition
-each row in a 1st table(3 rows) will joins with each row of 2nd table(4 rows).
cross join = 3 * 4 = 12 rows

ansi

ANSI
========
SQL> SELECT * FROM STUDENT CROSS JOIN COURSE;

      STID SNAME             CID        CID CNAME            CFEE
---------- ---------- ---------- ---------- ---------- ----------
      1021 SMITH              10         10 C                1000
      1022 ALLEN              20         10 C                1000
      1023 MILLER             30         10 C                1000
      1021 SMITH              10         20 ORACLE           2500
      1022 ALLEN              20         20 ORACLE           2500
      1023 MILLER             30         20 ORACLE           2500
      1021 SMITH              10         40 JAVA             5000
      1022 ALLEN              20         40 JAVA             5000
      1023 MILLER             30         40 JAVA             5000

9 rows selected.

NON ANSI
=========

SQL> SELECT * FROM STUDENT,COURSE;

      STID SNAME             CID        CID CNAME            CFEE
---------- ---------- ---------- ---------- ---------- ----------
      1021 SMITH              10         10 C                1000
      1022 ALLEN              20         10 C                1000
      1023 MILLER             30         10 C                1000
      1021 SMITH              10         20 ORACLE           2500
      1022 ALLEN              20         20 ORACLE           2500
      1023 MILLER             30         20 ORACLE           2500
      1021 SMITH              10         40 JAVA             5000
      1022 ALLEN              20         40 JAVA             5000
      1023 MILLER             30         40 JAVA             5000

9 rows selected.



SQL> SELECT * FROM COLORS CROSS JOIN SIZES;

NAME       SIZES
---------- ----------
RED        SMALL
RED        MEDIUM
RED        LARGE
BLUE       SMALL
BLUE       MEDIUM
BLUE       LARGE

6 rows selected.

SQL> SELECT * FROM ITEM1;

       SNO INAME           PRICE
---------- ---------- ----------
         1 PIZZA             180
         2 BURGER            180

SQL> SELECT * FROM ITEM2;

       SNO INAME           PRICE
---------- ---------- ----------
       101 PEPSI              25
       102 COCACOLA           20

SQL> SELECT I1.INAME,I1.PRICE,I2.INAME,I2.PRICE I1.PRICE+I2.PRICE TOTAL_BILL_AMOUT FROM ITEM1 I1 CROSS JOIN ITEM2 I2;
SELECT I1.INAME,I1.PRICE,I2.INAME,I2.PRICE I1.PRICE+I2.PRICE TOTAL_BILL_AMOUT FROM ITEM1 I1 CROSS JOIN ITEM2 I2
                                             *
ERROR at line 1:
ORA-00923: FROM keyword not found where expected


SQL> SELECT I1.INAME,I1.PRICE,I2.INAME,I2.PRICE,I1.PRICE+I2.PRICE TOTAL_BILL_AMOUT FROM ITEM1 I1 CROSS JOIN ITEM2 I2;

INAME           PRICE INAME           PRICE TOTAL_BILL_AMOUT
---------- ---------- ---------- ---------- ----------------
PIZZA             180 PEPSI              25              205
PIZZA             180 COCACOLA           20              200
BURGER            180 PEPSI              25              205
BURGER            180 COCACOLA           20              200

NATURAL JOIN
=============
-is similar to equi join.
-we must have a common column(mandatory) & datatype is same.
-user defined join condition is not needed.
-system is created a join condition based on an "=" operator along with common column name by default.
-to eliminate duplicate column names in result set.

SQL> SELECT * FROM STUDENT S NATURAL JOIN COURSE C;

       CID       STID SNAME      CNAME            CFEE
---------- ---------- ---------- ---------- ----------
        10       1021 SMITH      C                1000
        20       1022 ALLEN      ORACLE           2500

SELF JOIN
===========
-is working on single table
-joining a table by itself is called as "self join".
-when we implement self join mechanism we must be create alias name on table otherwise we can not implement self join.
-we can create any no of alias names on a table but each alias name should be different.

ex
===
 emp e1,emp e2, emp e3,emp e3 ,......

 -once we create alias names on a table internally system is creating virtual table on each alias name.


ex
===
 emp e1,emp e2, emp e3,emp e4 ,......


-there are two classes we can use self join mechanism,

Case-1 : comparing a single column values by itself with in the same table.
Case-2 : comparing two different columns values to each other with in the same table.




Case-1 : comparing a single column values by itself with in the same table.
================================================================================

ex
===
waq to display employees who are working in the same location the employee "smith" is also working?

SQL> SELECT T1.ENAME,T1.LOC FROM TEST T1, TEST T2 WHERE T1.LOC=T2.LOC AND T2.ENAME='SMITH';

ENAME      LOC
---------- ----------
SMITH      HYD
WARD       HYD


WAQ TO DISPLAY EMPLOYEE whose employee salary is same as the employee ford salary?

SQL> SELECT E1.ENAME,E1.SAL FROM EMP E1, EMP E2 WHERE E1.SAL=E2.SAL AND E2.ENAME='FORD';

ENAME             SAL
---------- ----------
SCOTT            3000
FORD             3000


Case-2 : comparing two different columns values to each other with in the same table.

EX- waq to display managers and their employees from emp?
SQL> SELECT M.ENAME MANAGER,E.ENAME EMPLOYEES FROM EMP E, EMP M WHERE M.EMPNO=E.MGR;

MANAGER    EMPLOYEES
---------- ----------
JONES      FORD
JONES      SCOTT
BLAKE      ALLEN
BLAKE      JAMES
BLAKE      TURNER
BLAKE      MARTIN
BLAKE      WARD
CLARK      MILLER
SCOTT      ADAMS
KING       BLAKE
KING       CLARK
KING       JONES
FORD       SMITH

13 rows selected.

waq to display employee who joined before their manager ?
========================================================


SQL> SELECT E.ENAME EMPLOYEE,E.HIREDATE EDOJ,M.ENAME MANAGER,M.HIREDATE FROM EMP E,EMP M WHERE M.EMPNO=E.MGR AND E.HIREDATE<M.HIREDATE;

EMPLOYEE   EDOJ      MANAGER    HIREDATE
---------- --------- ---------- ---------
ALLEN      20-FEB-81 BLAKE      01-MAY-81
WARD       22-FEB-81 BLAKE      01-MAY-81
BLAKE      01-MAY-81 KING       17-NOV-81
CLARK      09-JUN-81 KING       17-NOV-81
JONES      02-APR-81 KING       17-NOV-81
SMITH      17-DEC-80 FORD       03-DEC-81

6 rows selected.

How to join more than two tables
======================================
syntax for NON-ANSI format joins
===============================
select * from <tn1>,<tn2>,<tn3>,<tn4>,.................
where <condition1>and<condition2> and <condition 3>,............;

ex equijoin
===========


SQL> SELECT * FROM STUDENT;

      STID SNAME             CID
---------- ---------- ----------
      1021 SMITH              10
      1022 ALLEN              20
      1023 MILLER             30

SQL> SELECT * FROM COURSE;

       CID CNAME            CFEE
---------- ---------- ----------
        10 C                1000
        20 ORACLE           2500
        40 JAVA             5000

SQL> SELECT * FROM REGISTER;

     REGNO REGDATE          CID
---------- --------- ----------
         1 20-OCT-21         10
         2 21-OCT-21         20
        22 22-OCT-21         50

SQL> SELECT * FROM STUDENT S,COURSE C, REGISTER R WHERE S.CID=C.CID AND C.CID=R.CID;

      STID SNAME             CID        CID CNAME            CFEE      REGNO REGDATE          CID
---------- ---------- ---------- ---------- ---------- ---------- ---------- --------- ----------
      1021 SMITH              10         10 C                1000          1 20-OCT-21         10
      1022 ALLEN              20         20 ORACLE           2500          2 21-OCT-21         20

      SYNTAX FOR ANSI FORMAT
      ==========================
      select * from <tn1><join key><tn2>on<condition1><join key><tn3> on <condition2><join key><tn4> on <condition 3>.,
        ----------<join key><join key>on<condition n>


        innner join
        ================

SQL> SELECT * FROM STUDENT S INNER JOIN COURSE C ON S.CID=C.CID INNER JOIN REGISTER R ON C.CID=R.CID;

      STID SNAME             CID        CID CNAME            CFEE      REGNO REGDATE          CID
---------- ---------- ---------- ---------- ---------- ---------- ---------- --------- ----------
      1021 SMITH              10         10 C                1000          1 20-OCT-21         10
      1022 ALLEN              20         20 ORACLE           2500          2 21-OCT-21         20

Differences b/w joins & set operators
====================================
joins                                                   Set operators
=====                                                   =============
1.combining column wise                                  1.combinging row wise
2.combined data in horizontal manner                     2.combined data in vertically
3.it can perform different structures                    3.can perform same structure of tables
of table.

DATA INTEGRITY
==============
-accurate & consistency data in db tables.

1.Declarative Data integrity.
        -Pre-defined mechanism
        -by using "Constraints"[SQL]
2.Procedural Data integrity.
        -User defined
        -by using "Triggers"[PL/SQL]




1.Declarative Data integrity.
==============================
i)Enity integrity
=======================
       - each and every row is uniquely identify in a table.
       - Unique & Primary Key.
ii)Referential integrity
======================
        -to make relationships between tables
        -Foreign key | referential key
iii)Domain integrity
====================
    -to check values before inserting into a column.
    -Check,Not null,default

Constraints
==============
        -to restrict unwanted data/ invalid data into a table.


Types of constrainsts
=====================
-Unique
-Not null
-Check
-Primary key
-Foreign Key
-Default

Note: constraints are defining in two levels
===================
1.column level:
=================
        -to apply constraints on each column wise.

syntax
==========
create table<tn>(
<column name1><datatype>[size]<constrint type>,
<column name2><datatype>[size]<constrint type>,
-------------------------------------------------
-------------------------------------------------

)


2.Table level
===============
-to apply constraint after all columns are defined i.e end of the table.
create table <tn>(<col1><datatype[size]>,<col2><datatype>[size],..........<col n><datatype>[size],
-----------------------<constrant type>(<col1>,<col2>,<col3>,..........
)
)










































































































































































































































































































































































